class SocketRequest {

  /**
   * Manage a socket.
   * @param {Object} requestSocket Socket generated by Socket.io
   * @returns {Object} SocketRequest instance.
   */
  constructor (requestSocket) {
    this.socketRequestDate = new Date();
    this.socketRequestAdapter = requestSocket;
    this.socketRequestId = requestSocket.client.id;
    this.socketRequestPath = requestSocket.client.request.url;
    this.socketRequestMethod = requestSocket.client.request.method;
    this.socketRequestItems = this.socketRequestPath.substring(
        this.socketRequestPath.lastIndexOf('/') + 2,
        this.socketRequestPath.length
    );
    this.socketHandshake = requestSocket.handshake.issued;
  }
  
  /**
   * Get the start date of the request.
   * @returns {String} Locale date string.
   */
  date () {
    return this.socketRequestDate.toLocaleDateString();
  }
  
  /**
   * Get the start time of the request.
   * @returns {String} Locale time string.
   */
  time () {
    return this.socketRequestDate.toLocaleTimeString();
  }
  
  /**
   * Get the start date and timestamp.
   * @returns {String} Time and date of request.
   */
  timestamp () {
    return `${this.date()} @ ${this.time()}`;
  }
  
  /**
   * Generate a summary about the request.
   * @returns {String} Summary about the request.
   */
  summary () {
    return `Started for ${this.socketHandshake}.`;
  }

  /**
   * Authenticate a user.
   * @param {Function} requestHandler Custom handler function.
   */
  authenticate (requestHandler) {
    this.socketRequestAdapter.on('user:send', requestData => requestHandler('Authenticate', requestData));
  }

  /**
   * Report authentication to a user.
   * @param {Object} establishedUser Signed user object.
   */
  authenticated (establishedUser) {
    this.socketRequestAdapter.emit('user:suc', establishedUser);
  }

  /**
   * Report failed authentication.
   * @param {Error} unauthenticatedReason Reason for failure.
   */
  unauthenticated (unauthenticatedReason) {
    this.socketRequestAdapter.emit('user:fai', unauthenticatedReason);
  }

  /**
   * Register event listener.
   * @param {Function} registerHandler Function to handle register requests.
   */
  register (registerHandler) {
    this.socketRequestAdapter.on('client:send', registerData => registerHandler('Register', registerData));
  }

  /**
   * Register success emitter.
   * @param {Object} registeredObject Updated user/client combo.
   */
  registered (registeredObject) {
    this.socketRequestAdapter.emit('client:suc', registeredObject);
  }

  /**
   * Register failure emitter.
   * @param {Error} unregisteredReason Error event.
   */
  unregistered (unregisteredReason) {
    this.socketRequestAdapter.emit('client:fai', unregisteredReason);
  }

  // TODO: JSdoc.
  update (updateHandler) {
    this.socketRequestAdapter.on('update:send', updateData => updateHandler('Update', updateData));
  }

  // TODO: JSdoc.
  updated (updatedData) {
    this.socketRequestAdapter.emit('update:suc', updatedData);
  }

  // TODO: JSdoc.
  stagnated (stagnatedReason) {
    this.socketRequestAdapter.emit('update:fai', stagnatedReason);
  }

  // TODO: JSdoc.
  join (joinClient) {
    this.socketRequestAdapter.broadcast.emit('notif:join', joinClient);
  }

  // TODO: JSdoc.
  change (changeClient) {
    this.socketRequestAdapter.broadcast.emit('notif:change', changeClient);
  }

  // TODO: JSdoc.
  leave (leaveClient) {
    this.socketRequestAdapter.broadcast.emit('notif:leave', leaveClient);
  }

  /**
   * Disconnect event listener.
   * @param {Function} avoidHandler Custom handler for the disconnect event.
   */
  avoid (avoidHandler) {
    this.socketRequestAdapter.on('disconnect', disconnectData => avoidHandler('Avoid', disconnectData));
  }

}

module.exports = SocketRequest;